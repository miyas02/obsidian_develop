---

---
**åŒ¿åã‚¯ãƒ©ã‚¹**

ã‚¯ãƒ©ã‚¹åã‚’æŒ‡å®šã›ãšã«ã€ã‚¯ãƒ©ã‚¹å®šç¾©ã¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã‚’1ã¤ã®å¼ã¨ã—ã¦è¨˜è¿°ã—ãŸã‚¯ãƒ©ã‚¹ã®ã“ã¨ã€‚
åŒ¿åã‚¯ãƒ©ã‚¹ã¯ã‚ã‚‹ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã¾ãŸã¯ã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã—ãŸã‚¯ãƒ©ã‚¹ã€‚

**ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹**

- å¤‰æ•°å®£è¨€ã¯åˆæœŸåŒ–ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚ã—ãªã„ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼
- ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚¢ã‚¯ã‚»ã‚¹ä¿®é£¾å­ã¯publicã®ã¿ã€‚ä½•ã‚‚ã¤ã‘ãªã„ã¨å‹æ‰‹ã«publicãŒã¤ã
- ãƒ¡ã‚½ãƒƒãƒ‰ã«finalã‚’ä»˜ã‘ã‚‹ã®ç¦æ­¢
- æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã«staticç¦æ­¢
- staticãªå…·è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã¯å®šç¾©å¯èƒ½
    - ã‚¢ã‚¯ã‚»ã‚¹ä¿®é£¾å­ã¯publicã¾ãŸã¯private
- defaultã‚’ã¤ã‘ã‚Œã°ã€å…·è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©å¯èƒ½
- privateãªå…·è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚å®šç¾©å¯èƒ½

**ãƒã‚¹ãƒˆã‚¯ãƒ©ã‚¹**

- éstaticã‚¯ãƒ©ã‚¹
    - staticãƒ¡ãƒ³ãƒã‚’æŒã¦ãªã„
    - å¤–å´ã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã€staticå¤‰æ•°ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹
- staticã‚¯ãƒ©ã‚¹
    - staticãƒ¡ãƒ³ãƒã‚’æŒã¦ã‚‹
    - å¤–å´ã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„

**ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³**

**é–¢æ•°å‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹**

æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ãŒ1ã¤ã ã‘å®šç¾©ã•ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

é–¢æ•°å‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å¼•æ•°ã«å—ã‘å–ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€å‘¼ã³å‡ºã—å´ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼‰ãŒå®šç¾©ã—ãŸæŒ¯ã‚‹èˆã„ï¼ˆå‡¦ç†ï¼‰ã‚’ã€ãƒ¡ã‚½ãƒƒãƒ‰å†…ã§å®Ÿè¡Œã™ã‚‹ãŸã‚ã«ã‚ã‚‹

**ãƒ©ãƒ ãƒ€å¼
**`(å®Ÿè£…ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã®å¼•æ•°) -> {å‡¦ç†;}
`ãƒ©ãƒ ãƒ€å¼å…¨ä½“ãŒé–¢æ•°å‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ã®å‡¦ç†ã‚’å®Ÿè£…ã—ãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹

ãƒ©ãƒ ãƒ€å¼ã®å·¦è¾ºï¼ˆã¤ã¾ã‚Šã€ãƒ©ãƒ ãƒ€å¼ã®**å¼•æ•°ã®å‹**ï¼‰ã¯ã€**ä»£å…¥å…ˆã®é–¢æ•°å‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿**ã¨ä¸€è‡´ã™ã‚‹

**ã‚¹ãƒˆãƒªãƒ¼ãƒ API
**ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã€é…åˆ—ã€I/Oãƒªã‚½ãƒ¼ã‚¹ãªã©ã‚’é›†è¨ˆæ“ä½œã™ã‚‹API

### **ã‚¹ãƒˆãƒªãƒ¼ãƒ ç”Ÿæˆ**

**Collectionã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹**

```java
default Stream<E> stream()
```

**Arraysã‚¯ãƒ©ã‚¹**

```java
static<T> Stream<T> stream(T[] array)
static IntStream stream(int[] array)
```

**Streamã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹**

```java
static<T> Stream<T> of(T t)
static<T> Stream<T> of(Tâ€¦ values)
static<T> Stream<T> empty()
static<T> Stream<T> generate(Supplier<T> s)
```

**IntStreamã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹**

```java
static IntStream of(intâ€¦ values)
static IntStream iterate(int seed, IntUnaryOperator f)
static IntStream iterate(int seed, IntPredicate hasNext, IntUnaryOperator next)
static IntStream range(int startInclusive, int endExclusive)
static IntStream rangeClosed(int startInclusive, int endInclusive)
```

### **çµ‚ç«¯æ“ä½œ**

```java
boolean allMatch(Predicate<? super T> predicate)
boolean anyMatch(Predicate<? super T> predicate)
boolean noneMatch(Predicate<? super T> predicate)
<R,A> R collect(Collector<? super T,A,R> collector)
//Collectorsã‚¯ãƒ©ã‚¹ã®staticãƒ¡ã‚½ãƒƒãƒ‰ã‚’å¼•æ•°ã«æŒ‡å®š
<R> R collect(Supplier<R> supplier, BiConsumer<R,? super T> accumulator, BiConsumer<R,R> combiner>
long count()
Optional<T> findAny() 
Optional<T> findFirst()
void forEach(Consumer<? super T> action)
Optional<T> min(Comparator<? super T> comparator)
Optional<T> max(Comparator<? super T> comparator)
T reduce(T identity, BinaryOperator<T> accumulator)
Optional<T> reduce(BinaryOperator<T> accumulator)
//reduce â†’ é›†ç´„å‡¦ç†,åŠ ç®—ã€ä¹—ç®—ã€æ–‡å­—åˆ—çµåˆã€æœ€å°å€¤ã€æœ€å¤§å€¤ã®ã‚ˆã†ãªé›†ç´„å‡¦ç†ã«ä½¿ã†
//T identityã¯åˆæœŸå€¤ã€åˆæœŸå€¤ã‚’æŒ‡å®šã—ãªã„å ´åˆã¯Optional<T>ãŒè¿”ã‚‹
Object[] toArray()
<A> A[] toArray(IntFunction<A[]> generator)
```

### **ä¸­é–“æ“ä½œ**

```java
Stream<T> filter(Predicate<? super T> predicate)
Stream<T> distinct()
Stream<T> limit(long maxSize)
Stream<T> skip(long n)
<R> Stream<R> map(Function<? super T,? extends R> mapper)
<R> Stream<R> flatMap(Function<? super T,? extends Stream<? extends R>> mapper)
Stream<T> sorted()
Stream<T> sorted(Comparator<? super T> comparator)
Stream<T> peek(Consumer<? super T> action)
```

### **Optionalã‚¯ãƒ©ã‚¹**

```java
static<T> Optional<T> empty()
static<T> Optional<T> of(T value)
T get()
boolean isPresent()
boolean isEmpty()
void ifPresent(Consumer<? super T> consumer)
T orElse(T other)
T orElseGet(Supplier<? extends T>
<X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X extends Throwawble
```

### **Comparable**

è‡ªåˆ†è‡ªèº«ã®ä¸¦ã³é †ã‚’å®šç¾©
æ§‹é€ ä½“ã‚¯ãƒ©ã‚¹ãªã©ã«implements Comparabeã§å®Ÿè£…

```java
class Structure implements<Structure> {
//~~çœç•¥~~
  @Override
  public int compareTo(Person other) {
      return Integer.compare(this.id, other.id); // idé †
  }
}
Collections.sort(list) // compareToã«å¾“ã£ã¦ã‚½ãƒ¼ãƒˆ
```

### **Comparator**

å¤–éƒ¨ã‹ã‚‰ä¸¦ã³é †ã‚’å®šç¾©

```java
//ä½¿ç”¨ä¾‹
list.sort(Comparator.comparing(p -> p.name)); //åå‰é †ã§ã‚½ãƒ¼ãƒˆ
//comparingãƒ¡ã‚½ãƒƒãƒ‰
static <T,U extends Comparable<? super U>> Comparator<T> comparing(Function<? super T,? extends U> keyExtractor)
```

**ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ä¸€è¦§**

> [!note] ğŸ“Œ
> Collection(ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹) Listã‚„setã®å…±é€šã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
Collections(ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚¯ãƒ©ã‚¹) ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³æ“ä½œã®è£œåŠ©(ã‚½ãƒ¼ãƒˆã€åŒæœŸåŒ–ãªã©ï¼‰
Collector(ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹) collect()ã®ä¸­ã§ä½¿ã†é›†ç´„ã®ãƒ­ã‚¸ãƒƒã‚¯
Collectors(ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚¯ãƒ©ã‚¹) Collectorã®ä¾¿åˆ©ãªå®Ÿè£…ã‚’æä¾›

**Collectorsã‚¯ãƒ©ã‚¹ã®staticãƒ¡ã‚½ãƒƒãƒ‰**

Collectorã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã™
streamAPIã®collectãƒ¡ã‚½ãƒƒãƒ‰ã®å¼•æ•°ã«æ¸¡ã—ã¦ä½¿ã†

```java
Stream<String> stream = Stream.of("sampleA","sampleB","sampleC");
List<String> list = stream.collect(Collectors.toList());
```

```java
//<String,?,List<String>>ã¯Stream<String>ã‹ã‚‰List<String>ã‚’ç”Ÿæˆ
static<T> Collector<T,?,List<T>> toList()
static Collector<CharSequence,?,String> joining()
static Collector<CharSeqquence,?String> joining(CharSequence delimiter)
static <T> Collector<T,?,Integer> summingInt(ToIntFunction<? super T> mapper)
static<T> Collector<T,?,Double> averagingInt(ToIntFunction<? super T> mapper)
static<T> Collector<T,?,Set<T>> toSet()
static<T,K,U> Collector<T,?,Map<K,U>> toMap(Function<? super T,? extends K>key, Function<? super T,? extends U> value)
//Stream<String> stream1 = Stream.of("sampleA","sampleB","sampleC");
//Map<String, String> map1 = stream1.collect(Collectors.toMap(s -> s, s -> s.toUpperCase()) //å¼•æ•°1ãŒã‚­ãƒ¼,å¼•æ•°2ãŒvalueã®mapã‚’ç”Ÿæˆ
static<T,K,U> Collector<T,?,Map<K,U>> toMap(Function<? super T,? extends K> keyMapper, Function<? super T,? extends U> valueMapller,BinaryOperator<U> mergeFunction)
//Map<Integer, String> map2 = stream1.collect(Collectors.toMap(s -> s.length(), s -> s, (s1, s2) -> s1 + " : " + s2)); //å¼•æ•°1ãŒã‚­ãƒ¼,å¼•æ•°2ãŒvalue,å¼•æ•°3ãŒã‚­ãƒ¼ãŒé‡è¤‡ã—ãŸæ™‚ã®å‡¦ç†
static<T,K> Collector<T,?,Map<K,List<T>>> groupingBy(Function<? super T,? extends K> classifier)
//Map<String, List<String>>map = stream1.collect(Collectors.groupingBy(s -> s.substring(0, 1)); //Functionã®apply()ã®å¼•æ•°ã«è¦ç´ ã‚’æ¸¡ã—ã¦ã€ãƒãƒƒãƒ—ã®ã‚­ãƒ¼ã¨ãªã‚‹å€¤ã‚’è¿”ã™ã‚ˆã†ãªå‡¦ç†ã‚’æŒ‡å®šã™ã‚‹
//ä¸Šã®å‡¦ç†ã¯é ­æ–‡å­—ã‚’ã‚­ãƒ¼ã¨ã—ã¦ã€ã‚°ãƒ«ãƒ¼ãƒ”ãƒ³ã‚°ã—ã¦ã„ã‚‹
static<T,K> Collector<T,?,Map<K,List<T>>> groupingBy(Function<? super T,? extends K> classifier, Collector<? super T,A,D> downstream)
//ç¬¬2å¼•æ•°ã§ã¯ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ãŸãƒªã‚¹ãƒˆã«å¯¾ã—ã¦è¡Œã„ãŸã„å‡¦ç†ã‚’æŒ‡å®šã™ã‚‹
//Map<String, Set<String>>map1 = stream1.Collect(Collectos.groupingBy(s -> s.substring(0,1), Collectors.toSet()));
static<T,K> Collector<T,?,Map<K,List<T>>> groupingBy(Function<? super T,? extends K> classifier, Collector<? super T,A,D> downstream, Collector<? super T,A,D> downstream)
//TreeMapã‚’ä½¿ç”¨ã—ã¦ã‚­ãƒ¼ã®æ˜‡é †ã«ã‚ˆã‚‹é †åºä»˜ã‘ã‚’ç¶­æŒã—ãŸã„å ´åˆã«ä½¿ç”¨ã™ã‚‹
//Map<String, String> map3 = stream1.collect(Collectors.groupingBy(s -> s.substring(0, 1), TreeMap::new, Collectors.joining()));
static<T> COllector<T,?,Map<Boolean,List<T>>> partitioningBy(Predicate<? supert T> predicate)
//ã‚­ãƒ¼ãŒtrueã¾ãŸã¯falseã®mapã‚’ç”Ÿæˆã™ã‚‹
//Stream<Integer> stream1 = Stream.of(3, 5, 7, 9);
//Map<Boolean, List<Integer>> map1 = stream1.collect(Collectors.partitioningBy(s -> s > 5));
static<T> COllector<T,?,Map<Boolean,List<T>>> partitioningBy(Predicate<? supert T> predicate, Collector<? super T,A,D> downstream)
//ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ãŸãƒªã‚¹ãƒˆã«å¯¾ã—ã¦è¡Œã„ãŸã„å‡¦ç†ãŒã‚ã‚‹å ´åˆã«ä½¿ç”¨ã™ã‚‹
//Map<Boolean, Integer> map3 = stream2.collect(Collectors.partitioningBy(s -> s > 5, Collectors.summingInt(n -> n)));
static<T,U,A,R> Collector<T,?,R> mapping(Function<? super T,? extends U> mapper, Collector<? super U,A,R> downstream)
//mapãƒ¡ã‚½ãƒƒãƒ‰åŒæ§˜ã«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®å„è¦ç´ ã«å¯¾ã—ã¦è¡Œã„ãŸã„å‡¦ç†ã‚’æŒ‡å®šã™ã‚‹ã€‚ç¬¬2å¼•æ•°ã«ã¯ãƒãƒƒãƒ—å¾Œã«è¡Œã„ãŸã„å‡¦ç†ã‚’æŒ‡å®š
static<T> COllector<T,?,Optional<T>> maxBy(Comparator<? super T> comparator)
static<T> Collector<T,?,Optional<T>> minBy(Comparator<? super T> comparator)
```

**ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹**

<? super T>
ãƒ©ãƒ ãƒ€å¼ã®å·¦è¾ºã®å€¤ãŒTã¾ãŸã¯Tã®ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚¯ãƒ©ã‚¹ã§ã‚ã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ã€‚
`Consumer<? super Integer>` ã§ã‚ã‚Œã°ã€`Integer` ã®ã‚¹ãƒ¼ãƒ‘ãƒ¼ã‚¯ãƒ©ã‚¹ï¼ˆä¾‹ãˆã° `Number` ã‚„ `Object`ï¼‰ã‚’å—ã‘å–ã‚‹ `Consumer` ã‚’ä»£å…¥ã§ãã¾ã™ã€‚
`Consumer<? super Integer> target = num -> System.out.println("Number: " + num.doubleValue());`

# ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«

ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ä¸Šä½ã«ä½ç½®ã¥ã‘ã‚‰ã‚Œã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ã•ã‚‰ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã™ã‚‹ã€‚

```java
//module-info.java
module foo { //ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã¯.ã§åŒºåˆ‡ã£ãŸåå‰ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹
  exports xlib; //ã©ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’å…¬é–‹ã™ã‚‹ã‹ã‚’å®šç¾©
  requires hoge; //å¿…è¦ã¨ã—ã¦ã„ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‚’å®šç¾©. fooãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰hogeãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
  requires java.base; //ã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«æš—é»™çš„ã«å«ã¾ã‚Œã‚‹ãŸã‚çœç•¥å¯èƒ½
  requires transitive bar; //é–“æ¥ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ. fooã‚’requiresã—ãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯barãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚‚requiresã—ãŸã“ã¨ã«ãªã‚‹.
  provides xlib.MyInter with xlib.XTest, xlib.YTest; //ã€Œã‚µãƒ¼ãƒ“ã‚¹ã€ã«å¯¾ã™ã‚‹ã€Œã‚µãƒ¼ãƒ“ã‚¹ãƒ—ãƒ­ãƒã‚¤ãƒ€ã€ã‚’æŒ‡å®š.ã‚µãƒ¼ãƒ“ã‚¹ã¯ã‚µãƒ¼ãƒ“ã‚¹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®ã‚¯ãƒ©ã‚¹å.ã‚µãƒ¼ãƒ“ã‚¹ãƒ—ãƒ­ãƒã‚¤ãƒ€ã¯å®Ÿè£…ã‚¯ãƒ©ã‚¹åã‚’è¨˜è¿°.
  uses xlib.MyInter;
}
```

```powershell
#java javacã‚³ãƒãƒ³ãƒ‰
java --module-path #(-p) ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæ ¼ç´ã•ã‚Œã¦ã„ã‚‹ãƒ‘ã‚¹ã‚’æŒ‡å®š.
java --module #(-m) ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã¨ã‚¨ãƒ³ãƒˆãƒªãƒ»ãƒã‚¤ãƒ³ãƒˆã¨ãªã‚‹ã‚¯ãƒ©ã‚¹(mainã‚¯ãƒ©ã‚¹)ã‚’å®Œå…¨ä¿®é£¾åã§æŒ‡å®š.
java -module-path #jarãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ç”¨ã—ãŸå®Ÿè¡Œã§ã¯ã€-module-pathã§jarãƒ•ã‚¡ã‚¤ãƒ«ãŒä¿å­˜ã•ã‚Œã¦ã„ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’æŒ‡å®š.
javac -d <ã‚¯ãƒ©ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆå ´æ‰€> <ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«å¯¾è±¡ã®ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«>
javac -cp <classpath> #ã‚¯ãƒ©ã‚¹ãƒ‘ã‚¹æŒ‡å®šã‚ªãƒ—ã‚·ãƒ§ãƒ³ 
#javaã‚³ãƒãƒ³ãƒ‰
java --list-module #å‚ç…§å¯èƒ½ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‡ºåŠ›
java --describe-module (-d) #ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è¨˜è¿°å­ã®æƒ…å ±ã‚’å‡ºåŠ›
java --show-module-resolution #ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®è§£æ±ºã®æ§˜å­ã‚’å‡ºåŠ›
#jarã‚³ãƒãƒ³ãƒ‰
jar cvf [ãƒ•ã‚¡ã‚¤ãƒ«å].jar [å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ã‚„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª]
#jdepsã‚³ãƒãƒ³ãƒ‰
jdeps -summary (-s) #ä¾å­˜é–¢ä¿‚ã®ã‚µãƒãƒªãƒ¼ã‚’å‡ºåŠ›
jdeps -jdkinternals #JDKã®å†…éƒ¨APIã§ã‚¯ãƒ©ã‚¹ãƒ»ãƒ¬ãƒ™ãƒ«ã®ä¾å­˜é–¢ä¿‚ã‚’æ¤œç´¢
jdeps -dotoutput #DOTãƒ•ã‚¡ã‚¤ãƒ«ã®å‡ºåŠ›å…ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’æŒ‡å®š.
#jlinkã‚³ãƒãƒ³ãƒ‰
jlink --add-modules #ã‚¤ãƒ¡ãƒ¼ã‚¸ã«è¿½åŠ æ•°ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å›ºå®š
jlink --module-path (-p) #ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ»ãƒ‘ã‚¹ã‚’æŒ‡å®š
jlink --compress (-c) #ãƒªã‚½ãƒ¼ã‚¹ã®åœ§ç¸®ã‚’æœ‰åŠ¹åŒ– 0:åœ§ç¸®ãªã—, 1:å®šæ•°æ–‡å­—åˆ—ã®å…±æœ‰, 2:ZIP
jlink --launcher command=module (--launcher command=module/main) #ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ©ãƒ³ãƒãƒ£ãƒ¼ãƒ»ã‚³ãƒãƒ³ãƒ‰åã€ã¾ãŸã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŠã‚ˆã³ãƒ¡ã‚¤ãƒ³ãƒ»ã‚¯ãƒ©ã‚¹ã®ã‚³ãƒãƒ³ãƒ‰å
jlink --output #å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
```

### ç„¡åãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«

ã‚¯ãƒ©ã‚¹ãƒ‘ã‚¹ä¸Šã«å­˜åœ¨ã—ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‚’ã‚‚ãŸãªã„(module-info.classãŒãªã„)ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«

- ã™ã¹ã¦ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’exportsã™ã‚‹
- ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ‘ã‚¹ä¸Šã®ã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’requiresã™ã‚‹
- åå‰ä»˜ããƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰ç„¡åãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‚ç…§ã™ã‚‹ã“ã¨ã¯ã§ããªã„

### è‡ªå‹•ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«

ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ‘ã‚¹ä¸Šã«å­˜åœ¨ã—ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‚’ã‚‚ãŸãªã„(module-info.classãŒãªã„)ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
ä¾‹)è‡ªèº«ãŒä½œæˆã—ãŸã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŒ–ã•ã‚Œã¦ã„ã‚‹ãŒã€ãã®ä¸­ã§ä½¿ç”¨ã—ã¦ã„ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŒ–ã—ã¦ã„ãªã„ãªã©

- ã™ã¹ã¦ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’exportsã™ã‚‹
- ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ‘ã‚¹ä¸Šã®ã™ã¹ã¦ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’requiresã™ã‚‹
- åå‰ä»˜ããƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‹ã‚‰è‡ªå‹•ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å‚ç…§ãŒå¯èƒ½

